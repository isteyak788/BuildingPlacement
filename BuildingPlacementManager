using UnityEngine;
using UnityEngine.EventSystems; // Crucial for IsPointerOverUIObject
using UnityEngine.UI; // Required for Button component
using System.Collections.Generic;
using System.Linq; // Required for Min() and Max() extension methods

public class BuildingPlacementManager : MonoBehaviour
{
    // Singleton instance for easy access from other scripts
    public static BuildingPlacementManager Instance { get; private set; }

    [Header("Placement Settings")]
    [Tooltip("LayerMask for terrain/ground where buildings can be placed.")]
    public LayerMask placementLayerMask;
    [Tooltip("LayerMask for existing buildings or other objects that block placement.")]
    public LayerMask obstacleLayerMask; // NEW: For CanPlaceBuilding collision checks
    [Tooltip("Speed of building rotation when using Q and E keys (degrees per second).")]
    public float rotationSpeed = 90f;
    public float maxPlacementDistance = 100f; // Max distance for raycast from mouse
    [Tooltip("How high above the calculated base point to start the downward terrain raycasts.")]
    public float terrainRaycastStartHeight = 5f; // Ensures ray starts above any terrain bumps

    [Header("Input Keys")]
    [Tooltip("The key to rotate the building counter-clockwise.")]
    public KeyCode rotateLeftKey = KeyCode.Q; // Default to Q
    [Tooltip("The key to rotate the building clockwise.")]
    public KeyCode rotateRightKey = KeyCode.E; // Default to E
    [Tooltip("The key to hold for 45-degree rotation snapping.")]
    public KeyCode snapRotationModifierKey = KeyCode.LeftShift; // Default to Left Shift
    [Tooltip("The key to cancel the current building placement.")]
    public KeyCode cancelPlacementKey = KeyCode.Escape; // Default to Escape

    [Header("Building Data & Visuals")]
    [Tooltip("Assign all your BuildingData ScriptableObjects here. Order should correspond to UI buttons.")]
    public BuildingData[] availableBuildings;
    public Material validPlacementMaterial; // Green transparent material for valid preview
    public Material invalidPlacementMaterial; // Red transparent material for invalid preview

    [Header("UI References")]
    [Tooltip("Assign your main UI buttons here. Order should correspond to 'Available Buildings' array.")]
    public Button[] buildingButtons;
    [Tooltip("Drag and drop the UI Panel containing buttons for placement options (Single, Line, Box, etc.).")]
    [SerializeField] private GameObject placementSelectionPanel; // Assign this in Inspector

    [Header("Placement Mode Scripts")]
    [Tooltip("Reference to the SinglePlacementMode component on this or another GameObject.")]
    [SerializeField] private SinglePlacementMode singlePlacementMode;
    [Tooltip("Reference to the LinePlacementMode component on this or another GameObject.")]
    [SerializeField] private LinePlacementMode linePlacementMode;
    // Add more references to other placement mode scripts here as you create them

    private BuildingData selectedBuildingData; // The BuildingData currently selected for potential placement
    private BasePlacementMode activePlacementMode; // The currently active placement mode script

    // Expose selected building data and active mode for external scripts if needed
    public BuildingData SelectedBuildingData => selectedBuildingData;
    public BasePlacementMode ActivePlacementMode => activePlacementMode;

    // Property to check if any placement mode is active (for camera system)
    public bool IsPlacingBuilding => activePlacementMode != null;

    void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
        }
        else
        {
            Instance = this;
        }

        // Ensure placement modes are disabled initially
        if (singlePlacementMode != null) singlePlacementMode.enabled = false;
        if (linePlacementMode != null) linePlacementMode.enabled = false;
        // ... disable other modes
    }

    void Start()
    {
        // Hook up UI buttons to select buildings based on BuildingData
        for (int i = 0; i < buildingButtons.Length; i++)
        {
            if (i < availableBuildings.Length && availableBuildings[i] != null)
            {
                int dataIndex = i;
                buildingButtons[i].onClick.AddListener(() => SelectBuildingType(availableBuildings[dataIndex]));

                Text buttonText = buildingButtons[i].GetComponentInChildren<Text>();
                if (buttonText != null)
                    buttonText.text = availableBuildings[dataIndex].buildingName;

                Image buttonImage = buildingButtons[i].image;
                if (buttonImage != null && availableBuildings[dataIndex].buildingIcon != null)
                    buttonImage.sprite = availableBuildings[dataIndex].buildingIcon;
            }
            else
            {
                Debug.LogWarning($"Button at index {i} ('{buildingButtons[i].name}') has no corresponding BuildingData assigned or index out of bounds in 'availableBuildings' array.");
            }
        }

        // Hide the placement selection panel at start
        if (placementSelectionPanel != null)
        {
            placementSelectionPanel.SetActive(false);
        }
        ShowMainBuildingButtons(true); // Ensure main buttons are visible initially
    }

    void Update()
    {
        // If a placement mode is active, tell it to update its logic
        if (activePlacementMode != null)
        {
            activePlacementMode.UpdateMode();
        }

        // Key to cancel placement (configurable in Inspector)
        if (Input.GetKeyDown(cancelPlacementKey))
        {
            CancelPlacement();
        }
    }

    // --- Core Placement Logic ---

    // Called by UI buttons (e.g., the main building selection buttons)
    public void SelectBuildingType(BuildingData buildingData)
    {
        if (buildingData == null)
        {
            Debug.LogError("Attempted to select a null BuildingData.");
            return;
        }
        if (buildingData.initialConstructionPrefab == null)
        {
            Debug.LogError($"BuildingData for '{buildingData.buildingName}' is missing 'initialConstructionPrefab'. Cannot select.");
            return;
        }

        // If a building was already selected, and it's the same type, cancel current.
        // Otherwise, clear previous selection and prepare for new.
        if (selectedBuildingData == buildingData && activePlacementMode != null)
        {
            CancelPlacement(); // Clicking same button twice cancels
        }
        else
        {
            // First, cancel any existing active placement mode (this will also hide the panel)
            CancelPlacement();

            selectedBuildingData = buildingData;
            Debug.Log($"Building type selected: {selectedBuildingData.buildingName}");

            // --- NOW, ALWAYS SHOW THE PLACEMENT SELECTION PANEL ---
            ShowPlacementSelectionPanel(true);

            // --- THEN, CHECK FOR AND ACTIVATE DEFAULT PLACEMENT METHOD ---
            bool defaultMethodActivated = false;
            switch (selectedBuildingData.defaultPlacementMethod)
            {
                case BuildingPlacementMethodType.Single:
                    if (selectedBuildingData.allowSinglePlacement)
                    {
                        // Activate the mode. The panel remains visible because StartPlacementMode no longer hides it.
                        StartPlacementMode(singlePlacementMode);
                        defaultMethodActivated = true;
                    }
                    break;
                case BuildingPlacementMethodType.Line:
                    if (selectedBuildingData.allowLinePlacement)
                    {
                        // Activate the mode. The panel remains visible.
                        StartPlacementMode(linePlacementMode);
                        defaultMethodActivated = true;
                    }
                    break;
                // Add cases for other default placement types here (e.g., Box, Custom1)
                default:
                    // No default method specified or allowed, panel remains visible for user choice
                    break;
            }

            if (defaultMethodActivated)
            {
                Debug.Log($"Default placement method ({selectedBuildingData.defaultPlacementMethod}) auto-activated for {selectedBuildingData.buildingName}. Panel remains visible for choice.");
            }
            else
            {
                Debug.Log($"No default placement method for {selectedBuildingData.buildingName}. Please select a method from the panel.");
            }
        }
    }

    // Called by buttons on the 'placementSelectionPanel'
    public void SelectSinglePlacement()
    {
        if (selectedBuildingData == null || !selectedBuildingData.allowSinglePlacement)
        {
            Debug.LogWarning("Single placement not allowed or no building selected.");
            return;
        }

        // Manual selection: Activate the mode. The panel remains visible.
        StartPlacementMode(singlePlacementMode);
    }

    public void SelectLinePlacement()
    {
        if (selectedBuildingData == null || !selectedBuildingData.allowLinePlacement)
        {
            Debug.LogWarning("Line placement not allowed or no building selected.");
            return;
        }

        // Manual selection: Activate the mode. The panel remains visible.
        StartPlacementMode(linePlacementMode);
    }

    // General method to activate a specific placement mode
    // IMPORTANT: This method NO LONGER hides the panel.
    // The panel's visibility is now solely controlled by SelectBuildingType (to show) and CancelPlacement (to hide).
    private void StartPlacementMode(BasePlacementMode mode)
    {
        if (mode == null)
        {
            Debug.LogError($"Attempted to start a null placement mode: {mode.GetType().Name}. Check Inspector assignments.");
            CancelPlacement(); // Fallback to clear state
            return;
        }

        if (activePlacementMode != null)
        {
            activePlacementMode.ExitMode(); // Exit previous mode cleanly
            activePlacementMode.enabled = false;
        }

        activePlacementMode = mode;
        activePlacementMode.enabled = true; // Enable the script component
        activePlacementMode.EnterMode(this, selectedBuildingData); // Initialize the mode
    }


    // Cancels the current placement process, exiting the active mode
    public void CancelPlacement()
    {
        if (activePlacementMode != null)
        {
            activePlacementMode.ExitMode(); // Tell the mode to clean up its preview
            activePlacementMode.enabled = false; // Disable the script component
            activePlacementMode = null; // Clear reference
        }
        selectedBuildingData = null; // Clear the selected building data

        // --- ONLY REASON TO HIDE THE PLACEMENT SELECTION PANEL ---
        ShowPlacementSelectionPanel(false);
        ShowMainBuildingButtons(true); // Show main buttons again

        Debug.Log("Building placement cancelled.");
    }


    // --- Helper Methods (Resolving CS1061 Errors) ---

    /// <summary>
    /// Checks if the mouse pointer is currently over a UI object.
    /// Useful to prevent game world interaction when clicking UI buttons.
    /// Requires 'using UnityEngine.EventSystems;'
    /// </summary>
    public bool IsPointerOverUIObject()
    {
        if (EventSystem.current == null) return false; // No EventSystem in scene
        return EventSystem.current.IsPointerOverGameObject();
    }

    /// <summary>
    /// Performs a raycast from a given origin downwards to find terrain.
    /// </summary>
    /// <param name="origin">The starting point of the ray.</param>
    /// <param name="hit">Output: RaycastHit information.</param>
    /// <param name="layerMask">LayerMask for the terrain.</param>
    /// <returns>True if terrain was hit, false otherwise.</returns>
    public bool RaycastToTerrain(Vector3 origin, out RaycastHit hit, LayerMask layerMask)
    {
        // Use a small fixed distance for the raycast, as the origin is already above the terrain
        return Physics.Raycast(origin, Vector3.down, out hit, terrainRaycastStartHeight + 1f, layerMask);
    }


    /// <summary>
    /// Checks if a building can be placed at a given position and rotation.
    /// This performs footprint checks and terrain flatness checks.
    /// </summary>
    /// <param name="buildingData">The BuildingData for the building being placed.</param>
    /// <param name="position">The desired world position for the building (usually its base/center).</param>
    /// <param name="rotation">The desired world rotation for the building.</param>
    /// <returns>True if placement is valid, false otherwise.</returns>
    public bool CanPlaceBuilding(BuildingData buildingData, Vector3 position, Quaternion rotation)
    {
        if (buildingData == null || buildingData.initialConstructionPrefab == null)
        {
            // Debug.LogWarning("CanPlaceBuilding called with null buildingData or prefab.");
            return false;
        }

        // 1. Overlap Check: Check for collisions with other objects (buildings, obstacles)
        // Use the placement footprint size as a half-extents for the OverlapBox
        Vector3 halfExtents = buildingData.placementFootprintSize / 2f;
        
        // Adjust position so that the center of the OverlapBox aligns with the base of the building
        // Assuming building pivot is at its base, so we lift the box by half its Y size.
        Vector3 overlapBoxCenter = position + Vector3.up * halfExtents.y;

        // Using Physics.OverlapBox to detect colliders in the desired area
        // Ignore the preview itself by checking for its collider
        Collider[] colliders = Physics.OverlapBox(overlapBoxCenter, halfExtents, rotation, obstacleLayerMask);

        foreach (Collider col in colliders)
        {
            // Ensure we are not colliding with the preview instance itself
            // Or with the terrain/ground which is allowed
            if (col.isTrigger || ((1 << col.gameObject.layer) & placementLayerMask) != 0)
            {
                // Ignore triggers or the terrain layer
                continue;
            }
            if (activePlacementMode != null && activePlacementMode.gameObject == col.gameObject)
            {
                continue; // Ignore collisions with the placement manager's own collider
            }
            // If it's another non-trigger collider on the obstacle layer, it's an invalid placement
            return false;
        }

        // 2. Terrain Flatness Check: Ensure the ground under the building is relatively flat
        // This involves raycasting at multiple points within the footprint and comparing heights.

        float buildingHalfX = buildingData.placementFootprintSize.x / 2f;
        float buildingHalfZ = buildingData.placementFootprintSize.z / 2f;

        List<float> heights = new List<float>();

        // Calculate sample points within the footprint
        for (int x = 0; x < buildingData.terrainCheckGridDensity; x++)
        {
            for (int z = 0; z < buildingData.terrainCheckGridDensity; z++)
            {
                // Normalize coordinates from 0 to 1
                float normalizedX = (float)x / (buildingData.terrainCheckGridDensity - 1);
                float normalizedZ = (float)z / (buildingData.terrainCheckGridDensity - 1);

                // Map to local [-halfExtents, halfExtents] space
                float localX = Mathf.Lerp(-buildingHalfX, buildingHalfX, normalizedX);
                float localZ = Mathf.Lerp(-buildingHalfZ, buildingHalfZ, normalizedZ);

                // Transform local offset to world space relative to building's position and rotation
                Vector3 samplePointLocalOffset = new Vector3(localX, 0, localZ);
                Vector3 worldSamplePoint = position + rotation * samplePointLocalOffset;

                // Raycast downwards from above the terrain
                RaycastHit terrainHit;
                if (RaycastToTerrain(worldSamplePoint + Vector3.up * terrainRaycastStartHeight, out terrainHit, placementLayerMask))
                {
                    heights.Add(terrainHit.point.y);
                }
                else
                {
                    // If any sample point doesn't hit terrain, it's an invalid placement
                    return false;
                }
            }
        }

        // Check height difference
        if (heights.Count > 0)
        {
            float minHeight = heights.Min(); // Requires using System.Linq
            float maxHeight = heights.Max(); // Requires using System.Linq

            if (maxHeight - minHeight > buildingData.maxTerrainHeightDifference)
            {
                return false; // Terrain too steep
            }
        }

        // All checks passed
        return true;
    }

    /// <summary>
    /// Instantiates the final building prefab at the given position and rotation.
    /// </summary>
    /// <param name="buildingData">The BuildingData for the building to place.</param>
    /// <param name="position">The world position for the building.</param>
    /// <param name="rotation">The world rotation for the building.</param>
    public void PlaceBuilding(BuildingData buildingData, Vector3 position, Quaternion rotation)
    {
        if (buildingData == null || buildingData.initialConstructionPrefab == null)
        {
            Debug.LogError("Attempted to place building with null BuildingData or initialConstructionPrefab.");
            return;
        }

        // Instantiate the building prefab
        GameObject placedBuilding = Instantiate(buildingData.initialConstructionPrefab, position, rotation);

        // Optional: Implement a construction phase or other logic for the placed building
        // For example, if your buildings have a 'BuildingConstruction' script
        BuildingConstruction constructionScript = placedBuilding.GetComponent<BuildingConstruction>();
        if (constructionScript != null)
        {
            constructionScript.StartConstruction(buildingData.constructionTime, buildingData.finalPrefab);
        }
        else
        {
            Debug.LogWarning($"Building '{buildingData.buildingName}' placed but has no BuildingConstruction script attached.");
        }

        Debug.Log($"Successfully placed {buildingData.buildingName} at {position}.");
    }


    // --- UI Helper Methods ---

    // Helper to show/hide the main building selection buttons
    private void ShowMainBuildingButtons(bool show)
    {
        foreach (Button button in buildingButtons)
        {
            if (button != null) button.gameObject.SetActive(show);
        }
    }

    // Helper to show/hide the panel with placement options (Single, Line, etc.)
    private void ShowPlacementSelectionPanel(bool show)
    {
        if (placementSelectionPanel != null)
        {
            placementSelectionPanel.SetActive(show);
        }
    }
}
